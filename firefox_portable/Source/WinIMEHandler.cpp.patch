diff --git a/widget/windows/WinIMEHandler.cpp b/widget/windows/WinIMEHandler.cpp
--- a/widget/windows/WinIMEHandler.cpp
+++ b/widget/windows/WinIMEHandler.cpp
@@ -750,27 +750,35 @@ void IMEHandler::MaybeDismissOnScreenKey
                                }
                                if (!sFocusedWindow) {
                                  DismissOnScreenKeyboard(window);
                                }
                              }),
       EventQueuePriority::Idle);
 }
 
+static wchar_t to_ascii_lower(wchar_t c) {
+    if (c >= L'A' && c <= L'Z') {
+        return c - L'A' + L'a';
+    }
+    return c;
+}
+
 // static
-bool IMEHandler::WStringStartsWithCaseInsensitive(const std::wstring& aHaystack,
-                                                  const std::wstring& aNeedle) {
-  std::wstring lowerCaseHaystack(aHaystack);
-  std::wstring lowerCaseNeedle(aNeedle);
-  std::transform(lowerCaseHaystack.begin(), lowerCaseHaystack.end(),
-                 lowerCaseHaystack.begin(), ::tolower);
-  std::transform(lowerCaseNeedle.begin(), lowerCaseNeedle.end(),
-                 lowerCaseNeedle.begin(), ::tolower);
-  return wcsstr(lowerCaseHaystack.c_str(), lowerCaseNeedle.c_str()) ==
-         lowerCaseHaystack.c_str();
+bool IMEHandler::StartsWithCaseInsensitive(std::wstring_view aHaystack,
+                                           std::wstring_view aNeedle) {
+  if (aHaystack.length() < aNeedle.length()) {
+    return false;
+  }
+
+  return std::equal(aNeedle.begin(), aNeedle.end(), aHaystack.begin(),
+                    [](wchar_t needle_char, wchar_t haystack_char) {
+                      return to_ascii_lower(needle_char) ==
+                             to_ascii_lower(haystack_char);
+                    });
 }
 
 // Returns false if a physical keyboard is detected on Windows 8 and up,
 // or there is some other reason why an onscreen keyboard is not necessary.
 // Returns true if no keyboard is found and this device looks like it needs
 // an on-screen keyboard for text input.
 // static
 bool IMEHandler::NeedOnScreenKeyboard() {
@@ -866,27 +874,24 @@ bool IMEHandler::IsKeyboardPresentOnSlat
       break;
     }
 
     // Get the device ID.
     wchar_t device_id[MAX_DEVICE_ID_LEN];
     CONFIGRET status = ::CM_Get_Device_ID(device_info_data.DevInst, device_id,
                                           MAX_DEVICE_ID_LEN, 0);
     if (status == CR_SUCCESS) {
-      static const std::wstring BT_HID_DEVICE = L"HID\\{00001124";
-      static const std::wstring BT_HOGP_DEVICE = L"HID\\{00001812";
+      static constexpr std::wstring_view BT_HID_DEVICE = L"HID\\{00001124";
+      static constexpr std::wstring_view BT_HOGP_DEVICE = L"HID\\{00001812";
       // To reduce the scope of the hack we only look for ACPI and HID\\VID
       // prefixes in the keyboard device ids.
-      if (IMEHandler::WStringStartsWithCaseInsensitive(device_id, L"ACPI") ||
-          IMEHandler::WStringStartsWithCaseInsensitive(device_id,
-                                                       L"HID\\VID") ||
-          IMEHandler::WStringStartsWithCaseInsensitive(device_id,
-                                                       BT_HID_DEVICE) ||
-          IMEHandler::WStringStartsWithCaseInsensitive(device_id,
-                                                       BT_HOGP_DEVICE)) {
+      if (IMEHandler::StartsWithCaseInsensitive(device_id, L"ACPI") ||
+          IMEHandler::StartsWithCaseInsensitive(device_id, L"HID\\VID") ||
+          IMEHandler::StartsWithCaseInsensitive(device_id, BT_HID_DEVICE) ||
+          IMEHandler::StartsWithCaseInsensitive(device_id, BT_HOGP_DEVICE)) {
         // The heuristic we are using is to check the count of keyboards and
         // return true if the API's report one or more keyboards. Please note
         // that this will break for non keyboard devices which expose a
         // keyboard PDO.
         Preferences::SetString(kOskDebugReason,
                                L"IKPOS: Keyboard presence confirmed.");
         return true;
       }
