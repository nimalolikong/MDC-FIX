diff --git a/gfx/2d/2D.h b/gfx/2d/2D.h
--- a/gfx/2d/2D.h
+++ b/gfx/2d/2D.h
@@ -33,16 +33,19 @@
 #include "mozilla/StaticPtr.h"
 #include "mozilla/ThreadSafeWeakPtr.h"
 #include "mozilla/Atomics.h"
 
 #include "mozilla/DebugOnly.h"
 
 #include "nsRegionFwd.h"
 
+#include "mozilla/SSE.h"
+#include <string.h>
+
 #if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GTK)
 #  ifndef MOZ_ENABLE_FREETYPE
 #    define MOZ_ENABLE_FREETYPE
 #  endif
 #endif
 
 struct _cairo_surface;
 typedef _cairo_surface cairo_surface_t;
@@ -2028,18 +2031,20 @@ class DrawTarget : public external::Atom
    * enough not to require it.  At a future date this method may stop this
    * doing transform buffering so, if you're a consumer, please try to be smart
    * about calling this method as little as possible.  For example, instead of
    * concatenating a translation onto the current transform then calling
    * FillRect, try to integrate the translation into FillRect's aRect
    * argument's x/y offset.
    */
   virtual void SetTransform(const Matrix& aTransform) {
-    mTransform = aTransform;
-    mTransformDirty = true;
+    if (memcmp(&mTransform, &aTransform, sizeof(Matrix)) != 0) {
+      mTransform = aTransform;
+      mTransformDirty = true;
+    }
   }
 
   inline void ConcatTransform(const Matrix& aTransform) {
     SetTransform(aTransform * Matrix(GetTransform()));
   }
 
   SurfaceFormat GetFormat() const { return mFormat; }
 
@@ -2147,18 +2152,26 @@ struct Config {
 
 class GFX2D_API Factory {
   using char_type = filesystem::Path::value_type;
 
  public:
   static void Init(const Config& aConfig);
   static void ShutDown();
 
+#ifdef MOZILLA_MAY_SUPPORT_SSE2
+  static bool HasSSE2() { return supports_sse2(); }
+#else
   static bool HasSSE2();
+#endif
+#ifdef MOZILLA_MAY_SUPPORT_SSE4_1
+  static bool HasSSE4() { return supports_sse4_1(); }
+#else
   static bool HasSSE4();
+#endif
 
   /**
    * Returns false if any of the following are true:
    *
    *   - the width/height of |sz| are less than or equal to zero
    *   - the width/height of |sz| are greater than |limit|
    *   - the number of bytes that need to be allocated for the surface is too
    *     big to fit in an int32_t, or bigger than |allocLimit|, if specifed
