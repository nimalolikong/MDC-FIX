diff --git a/build/moz.configure/lto-pgo.configure b/build/moz.configure/lto-pgo.configure
--- a/build/moz.configure/lto-pgo.configure
+++ b/build/moz.configure/lto-pgo.configure
@@ -61,24 +61,41 @@ def llvm_profdata_order(profdata):
 option(
     "--with-pgo-profile-path",
     help="Path to the directory with unmerged profile data to use during the build"
     ", or to a merged profdata file",
     nargs=1,
 )
 
 
+option(
+    "--enable-cs-profile-generate",
+    env="MOZ_CS_PROFILE_GENERATE",
+    nargs="?",
+    help="Build a CSIR PGO instrumented binary",
+)
+
+@depends("--enable-cs-profile-generate")
+def cs_profile_generate(x):
+    if x:
+        return bool(x)
+
+set_config("MOZ_CS_PROFILE_GENERATE", cs_profile_generate)
+set_define("MOZ_CS_PROFILE_GENERATE", cs_profile_generate)
+
+
 @depends(
     "--with-pgo-profile-path",
     "--enable-profile-use",
     llvm_profdata,
     build_environment,
+    cs_profile_generate,
 )
 @imports("os")
-def pgo_profile_path(path, pgo_use, profdata, build_env):
+def pgo_profile_path(path, pgo_use, profdata, build_env, cs_profile_generate):
     topobjdir = build_env.topobjdir
     if topobjdir.endswith("/js/src"):
         topobjdir = topobjdir[:-7]
 
     if not path:
         return os.path.join(topobjdir, "instrumented", "merged.profdata")
     if path and not pgo_use:
         die("Pass --enable-profile-use to use --with-pgo-profile-path.")
@@ -125,26 +142,28 @@ pgo_temporal = c_compiler.try_compile(
 @depends(
     c_compiler,
     select_linker,
     target,
     pgo_profile_path,
     target_is_windows,
     pgo_temporal,
     orderfile_path,
+    cs_profile_generate,
 )
 @imports("multiprocessing")
 def pgo_flags(
     compiler,
     linker,
     target,
     profdata,
     target_is_windows,
     pgo_temporal,
     orderfile,
+    cs_profile_generate,
 ):
     if compiler.type == "gcc":
         return namespace(
             gen_cflags=["-fprofile-generate"],
             gen_ldflags=["-fprofile-generate"],
             use_cflags=["-fprofile-use", "-fprofile-correction", "-Wcoverage-mismatch"],
             use_ldflags=["-fprofile-use"],
         )
@@ -182,25 +201,49 @@ def pgo_flags(
             gen_cflags += ["-mllvm", "-pgo-temporal-instrumentation"]
 
         if target_is_windows:
             # native llvm-profdata.exe on Windows can't read profile data
             # if name compression is enabled (which cross-compiling enables
             # by default)
             gen_cflags += ["-mllvm", "-enable-name-compression=false"]
 
+        use_cflags = [
+            prefix + "-fprofile-use=%s" % profdata,
+            # Some error messages about mismatched profile data
+            # come in via -Wbackend-plugin, so disable those too.
+            "-Wno-error=backend-plugin",
+        ]
+
+        if target_is_windows:
+            use_ldflags += ["-lto-cs-profile-file:%s" % profdata]
+
+        if cs_profile_generate:
+            use_cflags += [prefix + "-fcs-profile-generate"]
+            if target_is_windows:
+                use_cflags += ["-mllvm", "-enable-name-compression=false"]
+                profile_lib = ""
+                if target.cpu == "x86":
+                    profile_lib = "clang_rt.profile-i386.lib"
+                elif target.cpu == "x86_64":
+                    profile_lib = "clang_rt.profile-x86_64.lib"
+                use_ldflags += [
+                    "-lto-cs-profile-generate",
+                    "-wholearchive:" + profile_lib,
+                ]
+
+        if compiler.version >= "18.1.0":
+            gen_cflags += ["-fprofile-update=atomic"]
+            if cs_profile_generate:
+                use_cflags += ["-fprofile-update=atomic"]
+
         return namespace(
             gen_cflags=gen_cflags,
             gen_ldflags=gen_ldflags,
-            use_cflags=[
-                prefix + "-fprofile-use=%s" % profdata,
-                # Some error messages about mismatched profile data
-                # come in via -Wbackend-plugin, so disable those too.
-                "-Wno-error=backend-plugin",
-            ],
+            use_cflags=use_cflags,
             use_ldflags=use_ldflags,
         )
 
 
 set_config("PROFILE_GEN_CFLAGS", pgo_flags.gen_cflags)
 set_config("PROFILE_GEN_LDFLAGS", pgo_flags.gen_ldflags)
 set_config("PROFILE_USE_CFLAGS", pgo_flags.use_cflags)
 set_config("PROFILE_USE_LDFLAGS", pgo_flags.use_ldflags)
@@ -266,28 +309,30 @@ imply_option("MOZ_LD64_KNOWN_GOOD", moz_
     c_compiler,
     select_linker,
     "MOZ_LD64_KNOWN_GOOD",
     target,
     "--enable-profile-generate",
     pass_manager.enabled,
     "--enable-profile-use",
     moz_automation,
+    "ENABLE_CSPGO",
 )
 @imports("multiprocessing")
 def lto(
     values,
     c_compiler,
     select_linker,
     ld64_known_good,
     target,
     instrumented_build,
     pass_manager,
     pgo_build,
     moz_automation,
+    enable_cspgo,
 ):
     cflags = []
     ldflags = []
     enabled = None
     rust_lto = False
 
     if not values:
         return
@@ -303,25 +348,24 @@ def lto(
     # default to it if MOZ_AUTOMATION and PGO are on, and for some platforms.
     # Based on speedometer3 scores, full lto + pgo is beneficial for Linux and
     # Windows for x86_64 targets.
     if values == () or values == ("cross",):
         if c_compiler.type == "gcc":
             values += ("full",)
         elif (
             pgo_build
-            and moz_automation
             and target.os in ("WINNT", "GNU")
             and target.cpu == "x86_64"
         ):
             values += ("full",)
         else:
             values += ("thin",)
 
-    if instrumented_build:
+    if instrumented_build and not enable_cspgo:
         log.warning("Disabling LTO because --enable-profile-generate is specified")
         return
 
     if c_compiler.type == "gcc":
         if "cross" in values:
             die("Cross-language LTO is not supported with GCC.")
         if "thin" in values:
             die(
@@ -400,37 +444,40 @@ def lto(
 
         ldflags.append("-flto=%s" % num_cores)
         ldflags.append("-flifetime-dse=1")
 
     # Tell LTO not to inline functions above a certain size, to mitigate
     # binary size growth while still getting good performance.
     # (For hot functions, PGO will put a multiplier on this limit.)
     if c_compiler.type == "clang-cl":
-        ldflags.append("-mllvm:-import-instr-limit=10")
+        ldflags.append("-mllvm:-import-instr-limit=21")
+        ldflags.append("-mllvm:-import-instr-evolution-factor=0.54")
     elif target.kernel == "Darwin":
-        ldflags.append("-Wl,-mllvm,-import-instr-limit=10")
+        ldflags.append("-Wl,-mllvm,-import-instr-limit=21")
+        ldflags.append("-Wl,-mllvm,-import-instr-evolution-factor=0.54")
     elif c_compiler.type == "clang":
-        ldflags.append("-Wl,-plugin-opt=-import-instr-limit=10")
+        ldflags.append("-Wl,-plugin-opt=-import-instr-limit=21")
+        ldflags.append("-Wl,-plugin-opt=-import-instr-evolution-factor=0.54")
 
     # If we're using the new pass manager, we can also enable the new PM
     # during LTO. Further we can use the resulting size savings to increase
     # the import limit in hot functions.
     if pass_manager:
         if c_compiler.type == "clang-cl":
             if c_compiler.version >= "12.0.0" and c_compiler.version < "13.0.0":
                 ldflags.append("-opt:ltonewpassmanager")
             if c_compiler.version >= "12.0.0":
-                ldflags.append("-mllvm:-import-hot-multiplier=30")
+                ldflags.append("-mllvm:-import-hot-multiplier=15")
         elif target.kernel == "Darwin":
-            ldflags.append("-Wl,-mllvm,-import-hot-multiplier=30")
+            ldflags.append("-Wl,-mllvm,-import-hot-multiplier=15")
         else:
             if c_compiler.version < "13.0.0":
                 ldflags.append("-Wl,-plugin-opt=new-pass-manager")
-            ldflags.append("-Wl,-plugin-opt=-import-hot-multiplier=30")
+            ldflags.append("-Wl,-plugin-opt=-import-hot-multiplier=15")
 
     # Pick Rust LTO mode in case of cross lTO. Thin is the default.
     if "cross" in values:
         rust_lto = "full" if "full" in values else "thin"
     else:
         rust_lto = ""
 
     return namespace(
