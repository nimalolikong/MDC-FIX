diff --git a/gfx/angle/checkout/src/compiler/translator/StaticType.h b/gfx/angle/checkout/src/compiler/translator/StaticType.h
--- a/gfx/angle/checkout/src/compiler/translator/StaticType.h
+++ b/gfx/angle/checkout/src/compiler/translator/StaticType.h
@@ -22,17 +22,17 @@ namespace Helpers
 {
 
 //
 // Generation and static allocation of type mangled name values.
 //
 
 // Size of the constexpr-generated mangled name.
 // If this value is too small, the compiler will produce errors.
-static constexpr size_t kStaticMangledNameLength = TBasicMangledName::mangledNameSize + 1;
+inline constexpr size_t kStaticMangledNameLength = TBasicMangledName::mangledNameSize + 1;
 
 // Type which holds the mangled names for constexpr-generated TTypes.
 // This simple struct is needed so that a char array can be returned by value.
 struct StaticMangledName
 {
     // If this array is too small, the compiler will produce errors.
     char name[kStaticMangledNameLength + 1] = {};
 };
@@ -52,17 +52,17 @@ constexpr StaticMangledName BuildStaticM
     name.name[1] = mangledName[0];
     name.name[2] = mangledName[1];
     name.name[3] = '\0';
     return name;
 }
 
 // Similar mangled name builder but for array types.  Currently, only single-dimension arrays of
 // single-digit size are necessary and supported.
-static constexpr size_t kStaticArrayMangledNameLength = kStaticMangledNameLength + 2;
+inline constexpr size_t kStaticArrayMangledNameLength = kStaticMangledNameLength + 2;
 struct StaticArrayMangledName
 {
     char name[kStaticArrayMangledNameLength + 1] = {};
 };
 constexpr StaticArrayMangledName BuildStaticArrayMangledName(TBasicType basicType,
                                                              TPrecision precision,
                                                              TQualifier qualifier,
                                                              uint8_t primarySize,
@@ -88,28 +88,28 @@ constexpr StaticArrayMangledName BuildSt
 // This "variable" contains the mangled names for every constexpr-generated TType.
 // If kMangledNameInstance<B, P, Q, PS, SS> is used anywhere (specifally
 // in instance, below), this is where the appropriate type will be stored.
 template <TBasicType basicType,
           TPrecision precision,
           TQualifier qualifier,
           uint8_t primarySize,
           uint8_t secondarySize>
-static constexpr StaticMangledName kMangledNameInstance =
+inline constexpr StaticMangledName kMangledNameInstance =
     BuildStaticMangledName(basicType, precision, qualifier, primarySize, secondarySize);
 
 // Same as kMangledNameInstance, but for array types.
 template <TBasicType basicType,
           TPrecision precision,
           TQualifier qualifier,
           uint8_t primarySize,
           uint8_t secondarySize,
           const unsigned int *arraySizes,
           size_t numArraySizes>
-static constexpr StaticArrayMangledName kMangledNameArrayInstance =
+inline constexpr StaticArrayMangledName kMangledNameArrayInstance =
     BuildStaticArrayMangledName(basicType,
                                 precision,
                                 qualifier,
                                 primarySize,
                                 secondarySize,
                                 arraySizes,
                                 numArraySizes);
 
@@ -124,34 +124,34 @@ static constexpr StaticArrayMangledName 
 // TODO(crbug.com/981610): This is constexpr but doesn't follow the kConstant naming convention
 // because TType has a mutable member that prevents it from being in .data.rel.ro and makes the
 // Android Binary Size builder complain when ANGLE is rolled in Chromium.
 template <TBasicType basicType,
           TPrecision precision,
           TQualifier qualifier,
           uint8_t primarySize,
           uint8_t secondarySize>
-static constexpr TType instance =
+inline constexpr TType instance =
     TType(basicType,
           precision,
           qualifier,
           primarySize,
           secondarySize,
           TSpan<const unsigned int>(),
           kMangledNameInstance<basicType, precision, qualifier, primarySize, secondarySize>.name);
 
 // Same as instance, but for array types.
 template <TBasicType basicType,
           TPrecision precision,
           TQualifier qualifier,
           uint8_t primarySize,
           uint8_t secondarySize,
           const unsigned int *arraySizes,
           size_t numArraySizes>
-static constexpr TType arrayInstance =
+inline constexpr TType arrayInstance =
     TType(basicType,
           precision,
           qualifier,
           primarySize,
           secondarySize,
           TSpan<const unsigned int>(arraySizes, numArraySizes),
           kMangledNameArrayInstance<basicType, precision, qualifier, primarySize, secondarySize, arraySizes, numArraySizes>.name);
 
