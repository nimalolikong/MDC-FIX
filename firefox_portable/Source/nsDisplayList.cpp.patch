diff --git a/layout/painting/nsDisplayList.cpp b/layout/painting/nsDisplayList.cpp
--- a/layout/painting/nsDisplayList.cpp
+++ b/layout/painting/nsDisplayList.cpp
@@ -5,16 +5,20 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  */
 
 /*
  * structures that represent things to be painted (ordered in z-order),
  * used during painting and hit testing
  */
 
+#if (_M_IX86_FP >= 1) || defined(__SSE__) || defined(_M_AMD64) || defined(__amd64__)
+#include <xmmintrin.h>
+#endif
+
 #include "nsDisplayList.h"
 
 #include <stdint.h>
 
 #include <algorithm>
 #include <limits>
 
 #include "ActiveLayerTracker.h"
@@ -2090,17 +2094,25 @@ nsRect nsDisplayList::GetClippedBounds(n
   }
   return bounds;
 }
 
 nsRect nsDisplayList::GetClippedBoundsWithRespectToASR(
     nsDisplayListBuilder* aBuilder, const ActiveScrolledRoot* aASR,
     nsRect* aBuildingRect) const {
   nsRect bounds;
-  for (nsDisplayItem* i : *this) {
+  const nsDisplayList& thisItems = *this;
+  for (auto it = thisItems.begin(); it != thisItems.end();) {
+    const auto& i = *it;
+    ++it;
+#if (_M_IX86_FP >= 1) || defined(__SSE__) || defined(_M_AMD64) || defined(__amd64__)
+    if (it != thisItems.end()) {
+      _mm_prefetch((char *)*it, _MM_HINT_NTA);
+    }
+#endif
     nsRect r = i->GetClippedBounds(aBuilder);
     if (aASR != i->GetActiveScrolledRoot() && !r.IsEmpty()) {
       if (Maybe<nsRect> clip = i->GetClipWithRespectToASR(aBuilder, aASR)) {
         r = clip.ref();
       }
     }
     if (aBuildingRect) {
       aBuildingRect->UnionRect(*aBuildingRect, i->GetBuildingRect());
@@ -2323,17 +2335,25 @@ void nsDisplayList::PaintRoot(nsDisplayL
   }
 
   fallback->EndTransactionWithList(aBuilder, this,
                                    presContext->AppUnitsPerDevPixel(),
                                    WindowRenderer::END_DEFAULT);
 }
 
 void nsDisplayList::DeleteAll(nsDisplayListBuilder* aBuilder) {
-  for (auto* item : TakeItems()) {
+  const nsDisplayList& takeItems = TakeItems();
+  for (auto it = takeItems.begin(); it != takeItems.end(); ++it) {
+    const auto& item = *it;
+#if (_M_IX86_FP >= 1) || defined(__SSE__) || defined(_M_AMD64) || defined(__amd64__)
+    if (it.mNode->mNext) {
+      _mm_prefetch((char *)it.mNode->mNext->mValue, _MM_HINT_NTA);
+      _mm_prefetch((char *)it.mNode->mNext->mValue + 64, _MM_HINT_NTA);
+    }
+#endif
     item->Destroy(aBuilder);
   }
 }
 
 static bool IsFrameReceivingPointerEvents(nsIFrame* aFrame) {
   return aFrame->Style()->PointerEvents() != StylePointerEvents::None;
 }
 
